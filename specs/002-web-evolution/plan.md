# Implementation Plan: Full-Stack Web Evolution (Phase II)

**Branch**: `002-web-evolution` | **Date**: 2026-01-01 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-web-evolution/spec.md`

**Note**: This plan was generated by the `/sp.plan` command following the SDD-RI methodology.

## Summary

Phase II transforms the console todo application into a production-ready, multi-tenant web application. The implementation uses Next.js 16+ (App Router) for the frontend, FastAPI for the backend API, Neon Serverless PostgreSQL for cloud database persistence, and Better Auth for JWT-based authentication. Core business logic from Phase I is preserved and adapted to work with SQLModel ORM, maintaining backward compatibility in terms of functionality while upgrading the technology stack.

**Technical Approach**:
- Frontend-backend separation with RESTful API
- JWT authentication with shared secret between Better Auth (frontend) and FastAPI (backend)
- Strict user isolation (The Identity Law): All database queries filtered by authenticated user_id
- Phase I skills adapted to SQLModel without rewriting business logic

## Technical Context

**Frontend**:
- **Language/Version**: TypeScript 5.0+, Node.js 18+
- **Framework**: Next.js 16+ (App Router)
- **Auth**: Better Auth with JWT
- **State Management**: React Context + useState
- **Styling**: Tailwind CSS

**Backend**:
- **Language/Version**: Python 3.13+
- **Framework**: FastAPI 0.110+
- **ORM**: SQLModel 0.0.14
- **Auth**: python-jose (JWT verification)

**Database**:
- **Storage**: Neon Serverless PostgreSQL 16+
- **Migrations**: Alembic
- **Connection Pooling**: Pg bouncer (Neon built-in)

**Testing**:
- **Backend**: pytest, pytest-asyncio
- **Frontend**: Jest, React Testing Library
- **E2E**: Playwright

**Target Platform**:
- **Backend**: Linux server (Docker), deployed on Fly.io/Railway
- **Frontend**: Vercel (serverless)
- **Database**: Neon (cloud-hosted PostgreSQL)

**Project Type**: Web (full-stack with frontend/backend separation)

**Performance Goals**:
- API response time: < 200ms p95
- Frontend initial load: < 2s
- Database queries: < 50ms p95
- Support 1000 concurrent users

**Constraints**:
- Multi-tenant with strict data isolation (The Identity Law)
- JWT expiration: 24 hours (configurable)
- CORS restricted to frontend domain only
- HTTPS required in production

**Scale/Scope**:
- Target: 10,000+ users
- Tasks per user: Up to 10,000
- API endpoints: 5 (GET, POST, PUT, DELETE, PATCH)
- Frontend pages: 3 (login, signup, dashboard)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Amendment II Compliance (Full-Stack Web & Identity)

✅ **The Identity Law Enforced**:
- Every task MUST be linked to `user_id` (foreign key in database schema)
- Backend MUST verify `Authorization: Bearer <JWT>` header (implemented in `auth.py`)
- Every database query MUST filter by authenticated `user_id` (enforced in all `skills.py` functions)
- No user shall ever see another user's data (403/404 responses for cross-user access attempts)

✅ **Technical Stack Requirements**:
- **Frontend**: Next.js 16+ (App Router) ✅
- **Backend**: Python FastAPI ✅
- **Database**: Neon Serverless PostgreSQL with SQLModel ORM ✅
- **Authentication**: Better Auth (Frontend) + JWT verification (Backend) ✅
- **API**: RESTful endpoints at `/api/{user_id}/tasks` ✅

✅ **Core Principles Maintained**:
- **Spec-Driven First**: Complete spec created before implementation ✅
- **Reusable Intelligence**: Phase I skills adapted (not rewritten), business logic preserved ✅
- **Human-Readable Design**: RESTful API, clear error messages, OpenAPI documentation ✅
- **Clean Phase Boundaries**: Web layer separate from business logic, Phase I skills remain core ✅

✅ **Security Requirements Met**:
- JWT secret shared between Better Auth and FastAPI backend ✅
- HTTPS required in production (enforced by deployment platforms) ✅
- SQL injection prevention via SQLModel parameterized queries ✅
- CORS configured for Next.js frontend only ✅

### Violations

**None.** This implementation fully complies with Amendment II and all core principles.

## Project Structure

### Documentation (this feature)

```text
specs/002-web-evolution/
├── spec.md              # Feature specification (user stories, requirements)
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (12 technical decisions)
├── data-model.md        # Phase 1 output (User, Task entities + SQLModel schemas)
├── quickstart.md        # Phase 1 output (implementation guide)
├── contracts/
│   └── openapi.yaml     # OpenAPI 3.0 specification for REST API
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT YET CREATED)
```

### Source Code (repository root)

**Structure**: Web application (frontend + backend separation)

```text
evolution-todo-app/
├── backend/                          # FastAPI backend (NEW)
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                   # FastAPI app initialization, CORS
│   │   ├── auth.py                   # JWT verification, verify_token()
│   │   ├── models.py                 # SQLModel schemas (User, Task)
│   │   ├── skills.py                 # Adapted Phase I skills (NEW)
│   │   ├── database.py               # Neon PostgreSQL connection
│   │   └── api/
│   │       ├── __init__.py
│   │       └── tasks.py              # Task CRUD endpoints
│   ├── alembic/                      # Database migrations
│   │   ├── versions/
│   │   └── env.py
│   ├── tests/
│   │   ├── test_auth.py              # JWT verification tests
│   │   ├── test_skills.py            # Adapted skills tests
│   │   └── test_api_tasks.py         # API endpoint tests
│   ├── requirements.txt
│   ├── .env                          # Environment variables
│   └── README.md
├── frontend/                         # Next.js frontend (NEW)
│   ├── app/
│   │   ├── page.tsx                  # Home/landing page
│   │   ├── login/
│   │   │   └── page.tsx              # Login page
│   │   ├── signup/
│   │   │   └── page.tsx              # Signup page
│   │   ├── dashboard/
│   │   │   └── page.tsx              # Task dashboard (protected)
│   │   ├── api/
│   │   │   └── auth/
│   │   │       └── [...all]/route.ts # Better Auth API routes
│   │   └── layout.tsx                # Root layout with providers
│   ├── components/
│   │   ├── TaskList.tsx              # Display tasks
│   │   ├── TaskForm.tsx              # Add/edit task form
│   │   ├── TaskItem.tsx              # Single task item
│   │   └── AuthGuard.tsx             # Protected route wrapper
│   ├── lib/
│   │   ├── auth.ts                   # Better Auth setup
│   │   ├── auth-context.tsx          # React Context for auth state
│   │   └── api.ts                    # API client with JWT injection
│   ├── package.json
│   ├── .env.local                    # Environment variables
│   ├── tailwind.config.ts
│   └── tsconfig.json
├── src/                              # Phase I (to be archived after migration)
│   ├── app.py
│   ├── cli/
│   ├── models/
│   └── skills/
├── specs/
│   ├── 001-in-memory-todo/           # Phase I spec
│   ├── 002-web-evolution/            # Phase II spec (current)
│   └── ARCHIVED-002-persistence-evolution/  # Superseded spec
└── .specify/
    └── memory/
        └── constitution.md           # Updated to v2.0.0 (Amendment II)
```

**Structure Decision**:

We adopt **Option 2: Web application** with frontend/backend separation. This is the industry-standard pattern for full-stack applications and enables:
- Independent deployment of frontend (Vercel) and backend (Fly.io/Railway)
- Technology-specific optimizations (Tailwind for frontend, FastAPI for backend)
- Team specialization (frontend vs backend developers)
- Horizontal scaling (multiple backend instances behind load balancer)

**Key Directories**:
- **NEW**: `backend/` - FastAPI REST API with SQLModel and Neon PostgreSQL
- **NEW**: `frontend/` - Next.js 16+ with Better Auth and Tailwind CSS
- **ARCHIVED**: `src/` - Phase I console app (will be moved to archive post-migration)

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No violations detected.** This implementation requires necessary complexity for a production web application:
- Frontend/backend separation is industry standard (not over-engineering)
- JWT authentication is security requirement (not optional)
- Database is necessary for multi-user persistence
- Better Auth simplifies auth implementation (reduces custom complexity)

---

## Implementation Architecture

### Three-Tier Architecture

```
┌──────────────────────────────────────────────────────────┐
│                  Tier 1: Frontend (Next.js)              │
│  ┌────────────────────────────────────────────────────┐  │
│  │ Better Auth (login/signup/session)                 │  │
│  │  - Generates JWT with user_id                      │  │
│  │  - Stores token in localStorage                    │  │
│  └────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────┐  │
│  │ Task Dashboard (React components)                  │  │
│  │  - TaskList, TaskForm, TaskItem                    │  │
│  │  - Calls API with JWT in Authorization header      │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────┬───────────────────────────────────┘
                       │ HTTPS + CORS
                       │ Authorization: Bearer <JWT>
                       ▼
┌──────────────────────────────────────────────────────────┐
│                  Tier 2: Backend (FastAPI)               │
│  ┌────────────────────────────────────────────────────┐  │
│  │ JWT Verification Middleware                        │  │
│  │  - Verifies JWT signature with BETTER_AUTH_SECRET  │  │
│  │  - Extracts user_id from token                     │  │
│  │  - Returns 401 if token invalid                    │  │
│  └────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────┐  │
│  │ REST API Endpoints (/api/{user_id}/tasks)          │  │
│  │  - GET, POST, PUT, DELETE, PATCH                   │  │
│  │  - Validates user_id matches JWT user_id (403)     │  │
│  │  - Delegates to adapted Phase I skills             │  │
│  └────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────┐  │
│  │ Adapted Phase I Skills (SQLModel)                  │  │
│  │  - create_task(user_id, title, desc, db)           │  │
│  │  - get_user_tasks(user_id, db)                     │  │
│  │  - update_task(id, user_id, title, desc, db)       │  │
│  │  - delete_task(id, user_id, db)                    │  │
│  │  - toggle_task_status(id, user_id, db)             │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────┬───────────────────────────────────┘
                       │ SQLModel ORM
                       │ Connection pooling
                       ▼
┌──────────────────────────────────────────────────────────┐
│          Tier 3: Database (Neon PostgreSQL)              │
│  ┌────────────────────────────────────────────────────┐  │
│  │ user table                                         │  │
│  │  - id, email, password_hash, timestamps            │  │
│  └────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────┐  │
│  │ tasks table                                        │  │
│  │  - id, user_id (FK), title, description,           │  │
│  │    completed, created_at, updated_at               │  │
│  │  - Index on user_id for efficient filtering        │  │
│  │  - Foreign key constraint with CASCADE DELETE      │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────┘
```

### Request Flow Example: Create Task

**Step 1**: User submits form in Next.js dashboard
```typescript
await taskApi.create(userId, { title: "New Task", description: "Details" });
```

**Step 2**: API client adds JWT header
```http
POST /api/123/tasks HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{"title": "New Task", "description": "Details"}
```

**Step 3**: FastAPI middleware verifies JWT
```python
# auth.py: verify_token()
payload = jwt.decode(token, BETTER_AUTH_SECRET, algorithms=["HS256"])
authenticated_user_id = payload["user_id"]  # Extract: 123
```

**Step 4**: Endpoint validates user_id match
```python
# api/tasks.py
if authenticated_user_id != url_user_id:
    raise HTTPException(403, "Forbidden")  # Prevents impersonation
```

**Step 5**: Adapted skill creates task in database
```python
# skills.py: create_task()
new_task = Task(user_id=123, title="New Task", description="Details", completed=False)
db.add(new_task)
db.commit()
```

**Step 6**: Response returned to frontend
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "id": 42,
  "user_id": 123,
  "title": "New Task",
  "description": "Details",
  "completed": false,
  "created_at": "2026-01-01T15:00:00Z",
  "updated_at": "2026-01-01T15:00:00Z"
}
```

**Step 7**: Frontend updates UI with new task

---

## Testing Strategy

### Backend Testing

**Unit Tests** (`backend/tests/test_skills.py`):
- Test adapted Phase I skills in isolation
- Mock database session
- Verify business logic preserved
- Test The Identity Law enforcement

**API Tests** (`backend/tests/test_api_tasks.py`):
- Test each endpoint with valid JWT
- Test 401 responses (missing/invalid JWT)
- Test 403 responses (user_id mismatch)
- Test 404 responses (task not found)
- Test 400 responses (validation errors)

**Integration Tests** (`backend/tests/test_integration.py`):
- Test full request flow with real database
- Use test database (separate from dev/prod)
- Verify multi-tenant isolation
- Test concurrent user scenarios

**Test Pyramid**:
- 60% unit tests (skills, auth, validation)
- 30% API tests (endpoint behavior)
- 10% integration tests (end-to-end with database)

### Frontend Testing

**Component Tests**:
- TaskList, TaskForm, TaskItem rendering
- User interactions (button clicks, form submission)
- Mock API responses

**Integration Tests**:
- Login flow
- Task CRUD operations
- Error handling

**E2E Tests** (Playwright):
- Complete user journey: signup → login → create task → toggle → delete
- Multi-user isolation verification

---

## Security Implementation

### JWT Verification Flow

```
1. Frontend: User logs in via Better Auth
2. Better Auth: Generates JWT with { user_id, email, exp }
3. Frontend: Stores JWT in localStorage
4. Frontend: Adds header: Authorization: Bearer <JWT>
5. Backend: Extracts JWT from Authorization header
6. Backend: Verifies signature with BETTER_AUTH_SECRET
7. Backend: Extracts user_id from verified JWT
8. Backend: Uses user_id for database queries
```

### The Identity Law Enforcement (3 Layers)

**Layer 1: JWT Verification** (Middleware)
```python
# All requests must have valid JWT
authenticated_user_id = verify_token(credentials)
# Returns 401 if invalid
```

**Layer 2: URL Validation** (Endpoint)
```python
# URL user_id must match JWT user_id
if authenticated_user_id != url_user_id:
    raise HTTPException(403, "Forbidden")
```

**Layer 3: Database Filtering** (Skills)
```python
# Every query filtered by user_id
tasks = db.query(Task).filter(Task.user_id == user_id).all()
# No cross-user access possible
```

### CORS Security

```python
# Only allow requests from Next.js frontend
allow_origins=["http://localhost:3000"]  # Dev
allow_origins=["https://todo.yourapp.com"]  # Prod
```

### SQL Injection Prevention

```python
# SQLModel uses parameterized queries automatically
statement = select(Task).where(Task.id == task_id)  # Safe
# NOT: f"SELECT * FROM tasks WHERE id = {task_id}"  # Vulnerable!
```

---

## Performance Optimization

### Database Indexes

```sql
-- Primary keys (automatic)
CREATE INDEX idx_user_id ON user(id);
CREATE INDEX idx_task_id ON tasks(id);

-- Foreign key for efficient joins
CREATE INDEX idx_tasks_user_id ON tasks(user_id);

-- Composite index for filtered queries
CREATE INDEX idx_tasks_user_id_id ON tasks(user_id, id);

-- Unique constraint for user lookups
CREATE UNIQUE INDEX idx_user_email ON user(email);
```

### Connection Pooling

```python
# backend/app/database.py
engine = create_engine(
    DATABASE_URL,
    pool_size=5,         # 5 persistent connections
    max_overflow=10,     # Up to 15 total connections
    pool_pre_ping=True   # Verify before use
)
```

### Frontend Optimization

- Server Components for initial page load (faster)
- Client Components only for interactive elements
- Lazy loading for dashboard components
- Optimistic UI updates (update UI before API confirms)

---

## Deployment Architecture

### Backend Deployment (Fly.io/Railway)

```dockerfile
# Dockerfile
FROM python:3.13-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app/ ./app/

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**Environment Variables** (Production):
```env
DATABASE_URL=postgresql://...@neon.tech/evolution-todo?sslmode=require
BETTER_AUTH_SECRET=<production-secret-32+-chars>
ALLOWED_ORIGINS=https://evolution-todo.vercel.app
ENVIRONMENT=production
```

### Frontend Deployment (Vercel)

**vercel.json**:
```json
{
  "env": {
    "NEXT_PUBLIC_API_URL": "https://api.evolution-todo.fly.dev",
    "BETTER_AUTH_SECRET": "@better-auth-secret",
    "BETTER_AUTH_URL": "https://evolution-todo.vercel.app"
  }
}
```

Auto-deploys on git push to main.

### Database (Neon)

- **Production branch**: `main`
- **Development branch**: `dev` (isolated database for testing)
- **Backups**: Automatic daily backups (Neon managed)
- **Scaling**: Auto-scale based on connection count

---

## Migration from Phase I

### Phase I → Phase II Skill Adaptation

| Phase I Skill | Phase II Skill | Key Changes |
|---------------|----------------|-------------|
| `AddTask(title, desc, tasks, next_id)` | `create_task(user_id, title, desc, db)` | Add user_id, use DB instead of list |
| `GetTasks(tasks)` | `get_user_tasks(user_id, db)` | Filter by user_id |
| `UpdateTask(id, title, desc, tasks)` | `update_task(id, user_id, title, desc, db)` | Add user_id for identity check |
| `DeleteTask(id, tasks)` | `delete_task(id, user_id, db)` | Add user_id for identity check |
| `ToggleTaskStatus(id, tasks)` | `toggle_task_status(id, user_id, db)` | Add user_id for identity check |

**Preserved Logic**:
- ✅ Title validation (non-empty, no whitespace-only)
- ✅ Task creation logic
- ✅ Update behavior (title/description modification)
- ✅ Delete behavior (task removal)
- ✅ Toggle behavior (completion status flip)

**New Logic** (security additions):
- JWT verification
- user_id extraction
- Identity Law enforcement (query filtering)
- HTTP error responses (401, 403, 404)

---

## Risk Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| JWT secret leaked | Low | Critical | Use environment variables, rotate regularly, never commit |
| Cross-user data access | Low | Critical | 3-layer enforcement (JWT, URL, DB filtering) |
| SQL injection | Very Low | High | SQLModel parameterized queries (automatic) |
| Database connection limits | Medium | Medium | Connection pooling, Neon auto-scaling |
| CORS misconfiguration | Low | High | Strict origin whitelist, test in staging |
| Phase I logic broken in migration | Low | Medium | Preserve business logic, comprehensive tests |
| Performance degradation | Medium | Medium | Database indexes, connection pooling, monitoring |

---

## Success Criteria

Phase II is complete when:
- [ ] Backend API running with all 5 endpoints functional
- [ ] Frontend deployed with login, signup, and dashboard
- [ ] Better Auth configured with JWT generation
- [ ] Database schema created (users, tasks tables)
- [ ] The Identity Law enforced (verified with multi-user tests)
- [ ] All API endpoints return correct status codes (200, 201, 204, 400, 401, 403, 404)
- [ ] Phase I skill logic preserved in adapted skills
- [ ] Frontend can create, view, update, delete, and toggle tasks
- [ ] Tasks persist across page refreshes and server restarts
- [ ] No user can access another user's tasks (verified with penetration testing)
- [ ] API documentation accessible at /docs
- [ ] All tests passing (unit, API, integration, E2E)

---

## Next Steps

**After /sp.plan completes**:
1. Run `/sp.tasks` to generate implementation tasks
2. Implement backend (FastAPI + SQLModel + Neon)
3. Implement frontend (Next.js + Better Auth)
4. Write comprehensive tests
5. Deploy to production (Vercel + Fly.io)
6. Verify security with penetration testing

**Future Phases** (Phase III ideas):
- Task tags and categories
- Task search and filtering
- Task due dates and reminders
- Task sharing between users
- Real-time collaboration (WebSockets)
- Mobile app (React Native)
