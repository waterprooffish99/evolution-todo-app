# Implementation Tasks: Persistence Evolution (Phase II)

**Feature**: 002-persistence-evolution
**Branch**: `002-persistence-evolution`
**Date**: 2026-01-01
**Generated by**: /sp.tasks command

## Overview

This document breaks down Phase II implementation into actionable, testable tasks organized by user story. Each user story phase is independently testable and can be completed incrementally.

**Total Tasks**: 28
**User Stories**: 4 (US1-P0, US2-P1, US3-P1, US4-P0)
**Estimated Completion**: 2-4 hours

## Task Legend

- `[P]` = Parallelizable (can run concurrently with other [P] tasks in same phase)
- `[US#]` = User Story label (maps to spec.md user stories)
- Task IDs: Sequential (T001, T002, ...)

## Implementation Strategy

**MVP Scope**: Complete US4 (Backward Compatibility) + US1 (Persistent Storage) first
- This provides core persistence functionality while maintaining Phase I compatibility
- US2 (Corruption Recovery) and US3 (Atomic Writes) can be added incrementally

**Incremental Delivery**:
1. Phase 1-2: Setup and foundational infrastructure
2. Phase 3: US4 - Ensure Phase I still works (regression testing)
3. Phase 4: US1 - Add basic persistence (load/save)
4. Phase 5: US3 - Add atomic writes (data safety)
5. Phase 6: US2 - Add corruption recovery (error handling)
6. Phase 7: Polish and performance validation

---

## Phase 1: Project Setup

**Goal**: Prepare project structure and dependencies for persistence layer

**Duration**: 10-15 minutes

### Tasks

- [ ] T001 Create data directory structure at project root (data/ with .gitkeep)
- [ ] T002 Update .gitignore to exclude data/ directory except .gitkeep
- [ ] T003 Create src/persistence.py stub file with function signatures from contracts/persistence-api.md
- [ ] T004 Verify Phase I tests still pass (pytest tests/test_skills.py -v)

**Acceptance**:
- data/ directory exists with .gitkeep
- .gitignore configured correctly
- src/persistence.py exists with function stubs
- All Phase I tests pass (baseline)

---

## Phase 2: Foundational Infrastructure

**Goal**: Implement core atomic write mechanism (required by all user stories)

**Duration**: 30-45 minutes

**Rationale**: Atomic writes are foundational for data integrity. All persistence operations depend on this.

### Tasks

- [ ] T005 Implement ensure_atomic_write() function in src/persistence.py using write-then-rename pattern
- [ ] T006 Add file path constants (DATA_DIR, DATA_FILE) in src/persistence.py
- [ ] T007 Add ensure_data_directory() helper function in src/persistence.py to create data/ if missing
- [ ] T008 Write unit test for ensure_atomic_write() in tests/test_persistence.py
- [ ] T009 Write unit test for ensure_data_directory() in tests/test_persistence.py

**Acceptance**:
- ensure_atomic_write() writes to .tmp then renames atomically
- ensure_data_directory() creates data/ directory if missing
- Unit tests pass for both functions

**Why Foundational**: All save operations require atomic writes. This must work correctly before implementing any user story.

---

## Phase 3: US4 - Backward Compatibility with Phase I (P0)

**User Story**: As a developer, I want all Phase I skills to remain unchanged in their signatures so that the persistence layer is transparent to the core logic.

**Independent Test Criteria**:
- All Phase I tests pass without modification (100% pass rate)
- Phase I skill signatures unchanged (no new parameters, no return type changes)
- Phase I skills have no imports of persistence module

**Duration**: 20-30 minutes

### Tasks

- [ ] T010 [US4] Verify Phase I skill signatures documented in tests/test_skills.py
- [ ] T011 [US4] Run Phase I test suite baseline (pytest tests/test_skills.py -v --tb=short)
- [ ] T012 [US4] Document expected function signatures for AddTask, UpdateTask, DeleteTask, ToggleTaskStatus, GetTasks
- [ ] T013 [US4] Create regression test fixture in tests/conftest.py to capture Phase I baseline

**Acceptance**:
- All Phase I tests documented and passing
- Function signatures captured for regression testing
- Baseline established for future comparisons

**Dependencies**: None (can start immediately after Phase 2)

---

## Phase 4: US1 - Persistent Task Storage (P0)

**User Story**: As a user, I want all my tasks to be automatically saved to a file so that my task list is preserved when I close and reopen the application.

**Independent Test Criteria**:
- Add task → restart app → task still exists
- Update task → restart app → changes persisted
- Delete task → restart app → task gone
- Toggle status → restart app → status persisted

**Duration**: 60-90 minutes

### Tasks

#### 4A: Load Functionality

- [ ] T014 [P] [US1] Implement load_tasks() function in src/persistence.py to read and parse JSON file
- [ ] T015 [P] [US1] Add JSON schema validation in load_tasks() (check version field, tasks list structure)
- [ ] T016 [P] [US1] Handle FileNotFoundError in load_tasks() (return empty list on first run)
- [ ] T017 [US1] Implement initialize_persistence() function in src/persistence.py
- [ ] T018 [US1] In initialize_persistence(), call load_tasks() and populate Phase I global state (tasks list)
- [ ] T019 [US1] In initialize_persistence(), set next_task_id to max(task IDs) + 1 or 1 if empty

#### 4B: Save Functionality

- [ ] T020 [P] [US1] Implement save_tasks() function in src/persistence.py using ensure_atomic_write()
- [ ] T021 [P] [US1] Create JSON structure with version field ("1.0") and tasks list in save_tasks()

#### 4C: Integration with CLI

- [ ] T022 [US1] Add import for initialize_persistence and save_tasks in src/main.py
- [ ] T023 [US1] Call initialize_persistence() at application startup in src/main.py (before menu loop)
- [ ] T024 [US1] Add save_tasks() call after AddTask in src/cli.py or src/main.py
- [ ] T025 [US1] Add save_tasks() call after UpdateTask in src/cli.py or src/main.py
- [ ] T026 [US1] Add save_tasks() call after DeleteTask in src/cli.py or src/main.py
- [ ] T027 [US1] Add save_tasks() call after ToggleTaskStatus in src/cli.py or src/main.py

#### 4D: Testing

- [ ] T028 [P] [US1] Write unit test for load_tasks() with valid JSON in tests/test_persistence.py
- [ ] T029 [P] [US1] Write unit test for load_tasks() with empty file in tests/test_persistence.py
- [ ] T030 [P] [US1] Write unit test for save_tasks() verifies JSON structure in tests/test_persistence.py
- [ ] T031 [P] [US1] Write integration test: add task → save → restart → load in tests/test_persistence_integration.py
- [ ] T032 [P] [US1] Write integration test: update task → save → restart → verify changes in tests/test_persistence_integration.py
- [ ] T033 [P] [US1] Write integration test: delete task → save → restart → verify gone in tests/test_persistence_integration.py
- [ ] T034 [P] [US1] Write integration test: toggle status → save → restart → verify status in tests/test_persistence_integration.py
- [ ] T035 [US1] Write integration test: task ID continuity after restart in tests/test_persistence_integration.py

**Acceptance**:
- load_tasks() correctly reads and parses data/todo_data.json
- save_tasks() writes valid JSON with version field
- initialize_persistence() populates Phase I state on startup
- All mutations trigger save_tasks()
- Integration tests verify persistence across restarts
- Task IDs continue correctly after restart (no reuse)

**Dependencies**:
- Phase 2 (atomic write mechanism)
- Phase 3 (Phase I baseline established)

**Parallel Opportunities**: Tasks T014-T016, T020-T021, T028-T034 can run in parallel

---

## Phase 5: US3 - Atomic Write Operations (P1)

**User Story**: As a user, I want all file write operations to be atomic so that my data is never partially written or corrupted during save operations.

**Independent Test Criteria**:
- Simulated crash during write → original file intact or fully updated (no partial writes)
- Multiple rapid saves → file always in consistent state
- Verify .tmp file used during write operations

**Duration**: 30-45 minutes

**Note**: Atomic write mechanism already implemented in Phase 2. This phase adds verification and testing.

### Tasks

- [ ] T036 [P] [US3] Write unit test to verify ensure_atomic_write() uses .tmp file in tests/test_persistence.py
- [ ] T037 [P] [US3] Write unit test to verify os.replace() is called (atomic rename) in tests/test_persistence.py
- [ ] T038 [US3] Write integration test simulating crash during write (mock exception) in tests/test_persistence_integration.py
- [ ] T039 [US3] Write integration test for rapid successive saves (stress test) in tests/test_persistence_integration.py
- [ ] T040 [US3] Manual test: Inspect data/ directory during save operation to confirm .tmp file usage

**Acceptance**:
- ensure_atomic_write() verified to use temp-then-rename strategy
- Tests confirm atomic behavior (no partial writes possible)
- Crash simulation shows old file preserved or new file complete
- Rapid saves handled correctly

**Dependencies**:
- Phase 4 (save_tasks() implementation complete)

**Parallel Opportunities**: Tasks T036-T037 can run in parallel

---

## Phase 6: US2 - Corrupted Data Recovery (P1)

**User Story**: As a user, I want the application to handle corrupted data files gracefully so that a malformed JSON file doesn't prevent me from using the application.

**Independent Test Criteria**:
- Corrupted JSON file → app displays error message
- Corrupted file backed up with timestamp
- User offered recovery options (fresh file or exit)
- User choice "fresh file" → new empty file created, app continues
- User choice "exit" → app exits gracefully

**Duration**: 45-60 minutes

### Tasks

#### 6A: Corruption Detection

- [ ] T041 [US2] Implement handle_corrupted_file() function in src/persistence.py
- [ ] T042 [US2] In handle_corrupted_file(), create backup with timestamp format: todo_data.json.corrupt.YYYY-MM-DDTHH-MM-SS
- [ ] T043 [US2] In handle_corrupted_file(), display error message to user with backup location
- [ ] T044 [US2] In handle_corrupted_file(), prompt user for choice (1=fresh file, 2=exit)
- [ ] T045 [US2] Handle user choice 1: create fresh empty JSON file and return empty task list
- [ ] T046 [US2] Handle user choice 2: exit application with sys.exit(1)

#### 6B: Integration with Load

- [ ] T047 [US2] Wrap load_tasks() JSON parsing in try/except for json.JSONDecodeError
- [ ] T048 [US2] On JSONDecodeError, call handle_corrupted_file() from load_tasks()

#### 6C: Testing

- [ ] T049 [P] [US2] Write unit test for handle_corrupted_file() with mocked user input (choice 1) in tests/test_persistence.py
- [ ] T050 [P] [US2] Write unit test for handle_corrupted_file() with mocked user input (choice 2) in tests/test_persistence.py
- [ ] T051 [P] [US2] Write unit test verifying backup file creation with timestamp in tests/test_persistence.py
- [ ] T052 [US2] Write integration test: corrupt JSON → backup created → fresh file → app continues in tests/test_persistence_integration.py
- [ ] T053 [US2] Write integration test: corrupt JSON → user exits → app exits cleanly in tests/test_persistence_integration.py
- [ ] T054 [US2] Manual test: Create corrupted JSON file, start app, verify error handling flow

**Acceptance**:
- json.JSONDecodeError caught and handled gracefully
- Corrupted files backed up with correct timestamp format
- User presented with clear recovery options
- Fresh file creation works correctly
- Exit option works correctly
- No crashes or unhandled exceptions

**Dependencies**:
- Phase 4 (load_tasks() implementation)

**Parallel Opportunities**: Tasks T049-T051 can run in parallel

---

## Phase 7: File System Error Handling

**Goal**: Handle permission errors, disk full, and other file system issues gracefully

**Duration**: 30-45 minutes

### Tasks

- [ ] T055 [P] Add PermissionError handling in initialize_persistence() with user-friendly message
- [ ] T056 [P] Add OSError (errno 28) handling in save_tasks() for disk full scenario
- [ ] T057 [P] Write unit test for PermissionError handling in tests/test_persistence.py
- [ ] T058 [P] Write unit test for disk full scenario in tests/test_persistence.py
- [ ] T059 Manual test: Remove write permissions from data/, verify error message

**Acceptance**:
- Permission errors display helpful messages with fix instructions
- Disk full errors preserve old file and display error
- No silent failures or unhandled exceptions

**Dependencies**: Phase 4 (basic persistence working)

**Parallel Opportunities**: All tasks in this phase can run in parallel

---

## Phase 8: Polish & Validation

**Goal**: Verify all acceptance criteria, performance targets, and documentation

**Duration**: 30-45 minutes

### Tasks

#### 8A: Regression & Compatibility

- [ ] T060 Run full Phase I test suite (pytest tests/test_skills.py -v) and verify 100% pass rate
- [ ] T061 Verify Phase I skill signatures unchanged (manual inspection of src/skills.py)
- [ ] T062 Run full Phase II test suite (pytest tests/ -v) and verify all tests pass

#### 8B: Performance Validation

- [ ] T063 Write performance test for load time with 1,000 tasks in tests/test_performance.py
- [ ] T064 Write performance test for save time with 100 tasks in tests/test_performance.py
- [ ] T065 Run performance tests and verify targets met (load < 1s, save < 100ms)

#### 8C: Code Quality

- [ ] T066 Run pytest with coverage (pytest tests/ --cov=src --cov-report=term-missing)
- [ ] T067 Verify persistence.py has > 90% coverage
- [ ] T068 Review and add docstrings to all persistence functions per FR-011 from spec.md

#### 8D: Manual Testing Scenarios

- [ ] T069 Manual test: Fresh start (no data file) → add tasks → restart → verify persistence
- [ ] T070 Manual test: Multiple operations → restart → all changes preserved
- [ ] T071 Manual test: Corrupt JSON file → recovery flow → fresh start
- [ ] T072 Manual test: 10,000 tasks scenario → verify performance warning if needed

#### 8E: Documentation

- [ ] T073 Update README.md with Phase II persistence features (if applicable)
- [ ] T074 Verify quickstart.md is accurate and usable
- [ ] T075 Document known limitations (e.g., no multi-instance locking) in README or plan.md

**Acceptance**:
- All Phase I tests pass (backward compatibility verified)
- All Phase II tests pass
- Performance targets met
- Code coverage > 90% for persistence.py
- All docstrings present per requirements
- Manual testing scenarios completed successfully
- Documentation updated

**Dependencies**: All previous phases complete

---

## Dependency Graph

**User Story Completion Order**:

```
Phase 1 (Setup)
     ↓
Phase 2 (Foundational: Atomic Writes) ← BLOCKING for all stories
     ↓
     ├─→ Phase 3: US4 (Backward Compatibility) ← Can start immediately
     │        ↓
     └─→ Phase 4: US1 (Persistent Storage) ← Depends on US4 baseline
              ↓
              ├─→ Phase 5: US3 (Atomic Write Testing) ← Verifies Phase 2
              │
              └─→ Phase 6: US2 (Corruption Recovery) ← Extends Phase 4
                       ↓
                  Phase 7 (Error Handling) ← Extends Phase 4
                       ↓
                  Phase 8 (Polish) ← Requires all above
```

**Critical Path**: Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 8 (minimum viable implementation)

**Story Independence**:
- US4 (Backward Compatibility): Independent, can start after Phase 2
- US1 (Persistent Storage): Depends on US4 baseline
- US3 (Atomic Writes): Depends on US1 (tests the implementation)
- US2 (Corruption Recovery): Depends on US1 (extends load functionality)

---

## Parallel Execution Examples

### Phase 4 (US1) Parallel Opportunities

**Group A** (Load functionality - no dependencies between these):
```bash
# Can run simultaneously
T014: Implement load_tasks()
T015: Add validation in load_tasks()
T016: Handle FileNotFoundError in load_tasks()
```

**Group B** (Save functionality - no dependencies between these):
```bash
# Can run simultaneously
T020: Implement save_tasks()
T021: Create JSON structure
```

**Group C** (Testing - all independent):
```bash
# Can run simultaneously
T028: Test load_tasks() with valid JSON
T029: Test load_tasks() with empty file
T030: Test save_tasks() structure
T031: Integration test: add → restart
T032: Integration test: update → restart
T033: Integration test: delete → restart
T034: Integration test: toggle → restart
```

### Phase 6 (US2) Parallel Opportunities

**Testing Group** (all independent):
```bash
# Can run simultaneously
T049: Test handle_corrupted_file() choice 1
T050: Test handle_corrupted_file() choice 2
T051: Test backup file creation
```

### Phase 7 (Error Handling) Parallel Opportunities

**All tasks** can run in parallel:
```bash
# Can run simultaneously
T055: PermissionError handling
T056: Disk full handling
T057: Test PermissionError
T058: Test disk full
```

---

## Testing Strategy Summary

**Test Distribution**:
- Unit tests: 18 tasks (T008, T009, T028-T030, T036-T037, T049-T051, T057-T058, T063-T064)
- Integration tests: 8 tasks (T031-T035, T038-T039, T052-T053)
- Manual tests: 5 tasks (T040, T054, T059, T069-T072)
- Regression tests: 3 tasks (T004, T011, T060)

**Coverage Targets**:
- Persistence module: > 90%
- Overall project: > 85%
- Phase I tests: 100% pass rate

**Test Pyramid**:
- 60% unit tests (fast, isolated)
- 30% integration tests (real file I/O)
- 10% manual/regression tests

---

## Success Criteria Checklist

Phase II is complete when:

- [ ] All Phase I tests pass without modification (US4)
- [ ] All Phase II persistence tests pass (unit + integration)
- [ ] Tasks persist across application restarts (US1)
- [ ] Corrupted JSON files handled gracefully with recovery options (US2)
- [ ] Atomic writes verified (no partial writes possible) (US3)
- [ ] File system errors handled with user-friendly messages
- [ ] Performance targets met (load < 1s for 1k tasks, save < 100ms)
- [ ] Code coverage > 90% for persistence.py
- [ ] All functions have docstrings per FR-011
- [ ] Manual testing scenarios completed successfully
- [ ] Constitution compliance verified (no violations)
- [ ] Documentation updated

---

## MVP Scope Recommendation

**Minimum Viable Product** (US4 + US1 only):
- Phase 1: Setup (T001-T004)
- Phase 2: Foundational (T005-T009)
- Phase 3: US4 Backward Compatibility (T010-T013)
- Phase 4: US1 Persistent Storage (T014-T035)
- Phase 8A: Regression validation (T060-T062)

**Total MVP Tasks**: 43 tasks
**Estimated Time**: 2-3 hours

This provides core persistence functionality with backward compatibility, deferring error handling and advanced features to later iterations.

---

## Notes

**Task Execution Tips**:
1. Start with Phase 1-2 (setup + foundational)
2. Complete US4 (backward compatibility baseline)
3. Implement US1 (core persistence) - largest effort
4. Add US3 and US2 incrementally for robustness
5. Polish phase verifies everything works correctly

**When to Stop and Test**:
- After Phase 2: Verify atomic write works
- After Phase 3: Confirm Phase I still passes
- After Phase 4: Run integration tests (persistence working)
- After Phase 6: Test all error scenarios
- After Phase 8: Final validation

**Common Pitfalls to Avoid**:
- Don't modify Phase I skill signatures (violates US4)
- Don't skip atomic write implementation (data corruption risk)
- Don't forget to call save_tasks() after all mutations
- Don't assume JSON file exists (handle FileNotFoundError)
- Don't write directly to target file (use .tmp + rename)

**Questions or Issues**: Refer to quickstart.md for detailed implementation guidance and contracts/persistence-api.md for function specifications.

---

**Generated**: 2026-01-01 | **Feature Branch**: 002-persistence-evolution | **Command**: /sp.tasks
